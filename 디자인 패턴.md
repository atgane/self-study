# 디자인 패턴의 종류

## single responsibility

모듈, 클래스, 함수는 하나의 부분에서만 응답을 가져야 한다고 되어있다. 매우 쉽고 당연하지만 놓치기 매우 쉽다. 

함수의 경우,

```python
def add(n1, n2): return n1 + n2
def numPrint(n): print(n)

def addPrint(n1, n2): ## 이런 함수는 필요 없다. 
    n = n1 + n2
    print(n)
    return n
```

클래스의 경우,

```python
class Cat:
    def __init__(self, age, name):
        self.age = age
        self.name = name

    def eat(self, food):
        pass

    def walk(self):
        pass

    def speak(self):
        pass

    """
    def print(self): 
        print(f"age:{self.age} name:{self.name}")

    def log(self, logger):
        logger.log(f"age:{self.age} name:{self.name}")
        logger.log(datetime.now())
    """

    ## 고양이에 대해서 생각해보면 먹기 걷기 말하기는 당연하지만 
    ## 프린트하기, 로그남기기는 고양이의 기능이라 볼 수 없다. 
    ## 고양이의 클래스에서 다른 방식으로 구현해야 한다. 
    ## 따라서 상태를 만들어주는 repr 함수를 만들 수 있다. 

    def repr(self):
        return f"age:{self.age} name:{self.name}"

## 이를 클라이언트에서 프린트를 하거나 로그를 남기게 할 수 있다.

kitty = Cat()
print(kitty.repr())
logger.log(kitty.repr())
```

## open-closed principle

확장은 개방, 수정은 폐쇄라는데, 이해가 안되니 예시를 보자.

open-closed를 준수하지 않는다면?
```python
class Animal:
    def __init__(self, a_type):
        self.a_type = a_type

def hey(animal: Animal):
    if animal.a_type == 'Cat':
        print('meow')
    elif animal.a_type == 'Dog':
        print('bark')
    else:
        raise Error('wrong a_type')

kitty = Animal('Cat')
bingo = Animal('Dog')

## 소와 양의 기능을 추가하는 순간 에러가 발생. 
## 다시 Animal hey을 수정해야한다.
## 이런 방법은 결국 한계를 만나게 된다. 
cow = Animal('Cow') 
sheep = Animal('sheep')
```

이를 해결하는 방법은 추상클래스나 인터페이스클래스를 사용하는 것이다. 

```python
class Animal: # 인터페이스
    def speak(self):
        pass

class Cat(Animal): ## 상속
    def speak(self):
        print('meow')

class Dog(Animal):
    def speak(self):
        print('bark')

def hey(animal: Animal):
    animal.speak()

kitty = Animal('Cat')
bingo = Animal('Dog')
cow = Animal('Cow') 
sheep = Animal('sheep')
```

open-closed principle을 준수하면 소와 양의 확장도 자유롭게 가능할 것이다. hey함수는 수정할 필요가 없을 것이다. 

```python
class Sheep(Animal):
    def speak(self):
        print("meh")


class Sheep(Animal):
    def speak(self):
        print("moo")
```

이렇게 animal을 인터페이스로 가지고 확장에 대해 열려있고 수정에 대해 닫혀있게 구조를 만들 수 있다. 상속을 알고 있었다면 자연스럽게 이 개념을 이용하고 있을지도 모른다. 