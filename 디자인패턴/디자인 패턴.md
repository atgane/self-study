# SOLID principles
객체지향 설계를 위한 5가지 원칙

## single responsibility

모듈, 클래스, 함수는 하나의 부분에서만 응답을 가져야 한다고 되어있다. 매우 쉽고 당연하지만 놓치기 매우 쉽다. 

함수의 경우,

```python
def add(n1, n2): return n1 + n2
def numPrint(n): print(n)

def addPrint(n1, n2): ## 이런 함수는 필요 없다. 
    n = n1 + n2
    print(n)
    return n
```

클래스의 경우,

```python
class Cat:
    def __init__(self, age, name):
        self.age = age
        self.name = name

    def eat(self, food):
        pass

    def walk(self):
        pass

    def speak(self):
        pass

    """
    def print(self): 
        print(f"age:{self.age} name:{self.name}")

    def log(self, logger):
        logger.log(f"age:{self.age} name:{self.name}")
        logger.log(datetime.now())
    """

    ## 고양이에 대해서 생각해보면 먹기 걷기 말하기는 당연하지만 
    ## 프린트하기, 로그남기기는 고양이의 기능이라 볼 수 없다. 
    ## 고양이의 클래스에서 다른 방식으로 구현해야 한다. 
    ## 따라서 상태를 만들어주는 repr 함수를 만들 수 있다. 

    def repr(self):
        return f"age:{self.age} name:{self.name}"

## 이를 클라이언트에서 프린트를 하거나 로그를 남기게 할 수 있다.

kitty = Cat()
print(kitty.repr())
logger.log(kitty.repr())
```

## open-closed principle

확장은 개방, 수정은 폐쇄라는데, 이해가 안되니 예시를 보자.

open-closed를 준수하지 않는다면?
```python
class Animal:
    def __init__(self, a_type):
        self.a_type = a_type

def hey(animal: Animal):
    if animal.a_type == 'Cat':
        print('meow')
    elif animal.a_type == 'Dog':
        print('bark')
    else:
        raise Error('wrong a_type')

kitty = Animal('Cat')
bingo = Animal('Dog')

## 소와 양의 기능을 추가하는 순간 에러가 발생. 
## 다시 Animal hey을 수정해야한다.
## 이런 방법은 결국 한계를 만나게 된다. 
cow = Animal('Cow') 
sheep = Animal('sheep')
```

이를 해결하는 방법은 추상클래스나 인터페이스클래스를 사용하는 것이다. 

```python
class Animal: # 인터페이스
    def speak(self):
        pass

class Cat(Animal): ## 상속
    def speak(self):
        print('meow')

class Dog(Animal):
    def speak(self):
        print('bark')

def hey(animal: Animal):
    animal.speak()

kitty = Animal('Cat')
bingo = Animal('Dog')
cow = Animal('Cow') 
sheep = Animal('sheep')
```

open-closed principle을 준수하면 소와 양의 확장도 자유롭게 가능할 것이다. hey함수는 수정할 필요가 없을 것이다. 

```python
class Sheep(Animal):
    def speak(self):
        print("meh")


class Sheep(Animal):
    def speak(self):
        print("moo")
```

이렇게 animal을 인터페이스로 가지고 확장에 대해 열려있고 수정에 대해 닫혀있게 구조를 만들 수 있다. 상속을 알고 있었다면 자연스럽게 이 개념을 이용하고 있을지도 모른다. 

## Liskov Substitution principle

타입 *S*가 *T*의 부분타입일 때 객체 *T*는 객체 *S*로 치환 가능하다. 라는데 뭔소릴까.

타입 *T*의 부분 타입 *S1, S2, S3*들이 각각 있다 하자. 이때 타입 *T*를 *S1, S2, S3*로 바꿔도 프로그램이 동작 가능해야 한다는 의미이다. 

고양이 클래스가 있고, 검은 고양이, 길고양이가 있다면, 프로그램 내에서 일반적인 고양이를 검은 고양이나 길고양이로 치환해도 전체적인 프로그램이 돌아가야 한다는 뜻이다. 

```python
class Cat:
    def speak(self):
        print('meow')

class BlackCat(Cat):
    def speak(self):
        print("black meow")
    
def speak(cat: Cat):
    cat.speak()

cat = Cat()
speak(cat)
```

여기서 고양이를 검은 고양이라 해도 meow라고 대답할 것이다. 

```python
cat = BlackCat()
speak(cat)
```

그런데 여기서 생선 클래스를 넣으라는 요청이 들어왔다 했을 때, 생선은 말을 할 수 없으므로 오류처리를 할 것이다. 

```python
class Fish(Cat):
    def speak(self):
        raise Exception("Fish cannot speak")

cat = Fish()
speak(cat)
```

따라서 cat을 Fish의 인스턴스로 한다면 말을 하지 못한다. 이 경우, 리스코프 치환 법칙을 위배하게 된다. 

이를 해결하기 위해서는 전체적인 클래스 구조를 잡고 만들어야 한다. 또는 다른 방법을 사용해야 한다. 

## Interface segregation

인터페이스 분리 원칙이란 클라이언트를 사용하지 않을 메서드에 의존하지 않도록 하는 것이다. 큰 인터페이스를 작은 단위로 분리시켜야 한다는 것이다. 

인터페이스이 뭘까? C++나 python에게는 어색한 개념일 것이다. C#을 기준으로 한다. 

```cs
interface ICar // ICar 인터페이스 생성. 운전 좌회전 우회전 기능을 명시
{
    void drive(); 
    void turnLeft();
    void turnRight();
}

class Genesis:ICar // ICar 인터페이스를 갖는 제네시스 클래스 구현
{
    void drive(){
        // 운전 구현
    }
    void turnLeft(){
        // 좌회전 구현
    }
    void turnRight(){
        // 우회전 구현
    }
}

class Avante:ICar // ICar 인터페이스를 갖는 아반떼 클래스 구현
{
    void drive(){
        // 운전 구현
    }
    void turnLeft(){
        // 좌회전 구현
    }
    void turnRight(){
        // 우회전 구현
    }
}

Avante nocopeCar = new Avante();
Genesis secondCar = new Genesis();
```

인터페이스 분리 원칙이란 이런 인터페이스를 너무 큰 개념으로 잡지 말라는 것이다. 예를 들어, 수륙양용차도 인터페이스로 추가시키면, 운전 자회전 우회전 외에 조종하기, 조종 왼쪽, 조종 오른쪽과 같은 함수를 추가해야 한다. 

```cs
interface ICarBoat
{
    void drive(); 
    void turnLeft();
    void turnRight();
    
    void steer();
    void steerLeft();
    void steerRight();
}
```

이렇게 인터페이스를 키우면, 아반떼나 제네시스에서 사용하지 않는 메서드가 존재하게 된다. 따라서 인터페이스를 분리하여 사용하지 않는 메서드가 없도록 하자는 것이다. Icar인터페이스랑 Iboat인터페이스를 만들고 수륙양용차의 경우, 두 인터페이스가 들어올 수 있도록 하는 것이 좋다. 

```cs
interface ICarBoat
{
    void drive(); 
    void turnLeft();
    void turnRight();
}
interface IBoat
{
    void steer();
    void steerLeft();
    void steerRight();
}

class CarBoat: ICar, IBoat
{
    // ...
}
```

이렇게 위의 방법처럼 인터페이스를 분리할 수 있다. 

## Dependency inversion

동물원을 만들고 강아지랑 고양이를 넣는다면, 동물원은 고양이와 강아지의 dependency를 가지고 있다. 동물원은 더 많은 정보를 가지고 있기 때문에 high level module로 볼 수 있고 고양이와 강아지는 low level module로 볼 수 있다. 

```python
class Cat:
    def speak(self):
        print("meow")

class Dog:
    def speak(self):
        print("bark")

class Zoo:
    def __init__(self):
        self.cat = Cat()
        self.dog = Dog()
```

위와 같은 흐름은 자연스럽다. 그러나 소랑 양이 추가된다고 하면 더 많은 low level module에 대한 dependency가 생긴다. 이렇게 계속 high level module의 dependency가 증가하면 코드의 수정과 관리가 어렵게 된다. 이를 해결하기 위해 dependency inversion을 사용하는 것이다. 

high level module인 동물원을 abstract module인 동물에 의존하게 만들고, 고양이와 강아지도 동물에 의존하게 하는 것이다. 이를 코드로 나타내면 다음과 같다. 

```python
class Animal: 
    def speak(self):
        pass
    
class Cat(Animal):
    def speak(self):
        print("meow")
        
class Cat(Animal):
    def speak(self):
        print("bark")


class Zoo:
    def __init__(self):
        self.animals = []

    def addAnimal(self, animal):
        self.animals.append(animal)
    
    def speakAll(self):
        for animal in self.animals:
            animal.speak()

zoo = Zoo()
zoo.addAnimal(Cat())
zoo.addAnimal(Dog())
zoo.speakAll()
```

dependency inversion 구조를 갖게 되면 나중에 동물이 추가되더라도 동물원은 건드릴 필요가 없다. 다시 말해서 high level module을 low level에 의존하게 만드는 것이 아니라 추상화 module을 만들어 추상화 클래스에 의존하게 하는 것이다. 이 과정에서 화살표의 방향이 바뀌기 때문에 dependency inversion이라 부른다. 