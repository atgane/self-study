# 디자인 패턴의 종류

## single responsibility

모듈, 클래스, 함수는 하나의 부분에서만 응답을 가져야 한다고 되어있다. 매우 쉽고 당연하지만 놓치기 매우 쉽다. 

함수의 경우,

```python
def add(n1, n2): return n1 + n2
def numPrint(n): print(n)

def addPrint(n1, n2): ## 이런 함수는 필요 없다. 
    n = n1 + n2
    print(n)
    return n
```

클래스의 경우,

```python
class Cat:
    def __init__(self, age, name):
        self.age = age
        self.name = name

    def eat(self, food):
        pass

    def walk(self):
        pass

    def speak(self):
        pass

    """
    def print(self): 
        print(f"age:{self.age} name:{self.name}")

    def log(self, logger):
        logger.log(f"age:{self.age} name:{self.name}")
        logger.log(datetime.now())
    """

    ## 고양이에 대해서 생각해보면 먹기 걷기 말하기는 당연하지만 
    ## 프린트하기, 로그남기기는 고양이의 기능이라 볼 수 없다. 
    ## 고양이의 클래스에서 다른 방식으로 구현해야 한다. 
    ## 따라서 상태를 만들어주는 repr 함수를 만들 수 있다. 

    def repr(self):
        return f"age:{self.age} name:{self.name}"

## 이를 클라이언트에서 프린트를 하거나 로그를 남기게 할 수 있다.

kitty = Cat()
print(kitty.repr())
logger.log(kitty.repr())
```

## open-closed principle

확장은 개방, 수정은 폐쇄라는데, 이해가 안되니 예시를 보자.

open-closed를 준수하지 않는다면?
```python
class Animal:
    def __init__(self, a_type):
        self.a_type = a_type

def hey(animal: Animal):
    if animal.a_type == 'Cat':
        print('meow')
    elif animal.a_type == 'Dog':
        print('bark')
    else:
        raise Error('wrong a_type')

kitty = Animal('Cat')
bingo = Animal('Dog')

## 소와 양의 기능을 추가하는 순간 에러가 발생. 
## 다시 Animal hey을 수정해야한다.
## 이런 방법은 결국 한계를 만나게 된다. 
cow = Animal('Cow') 
sheep = Animal('sheep')
```

이를 해결하는 방법은 추상클래스나 인터페이스클래스를 사용하는 것이다. 

```python
class Animal: # 인터페이스
    def speak(self):
        pass

class Cat(Animal): ## 상속
    def speak(self):
        print('meow')

class Dog(Animal):
    def speak(self):
        print('bark')

def hey(animal: Animal):
    animal.speak()

kitty = Animal('Cat')
bingo = Animal('Dog')
cow = Animal('Cow') 
sheep = Animal('sheep')
```

open-closed principle을 준수하면 소와 양의 확장도 자유롭게 가능할 것이다. hey함수는 수정할 필요가 없을 것이다. 

```python
class Sheep(Animal):
    def speak(self):
        print("meh")


class Sheep(Animal):
    def speak(self):
        print("moo")
```

이렇게 animal을 인터페이스로 가지고 확장에 대해 열려있고 수정에 대해 닫혀있게 구조를 만들 수 있다. 상속을 알고 있었다면 자연스럽게 이 개념을 이용하고 있을지도 모른다. 

## Liskov Substitution principle

타입 *S*가 *T*의 부분타입일 때 객체 *T*는 객체 *S*로 치환 가능하다. 라는데 뭔소릴까.

타입 *T*의 부분 타입 *S1, S2, S3*들이 각각 있다 하자. 이때 타입 *T*를 *S1, S2, S3*로 바꿔도 프로그램이 동작 가능해야 한다는 의미이다. 

고양이 클래스가 있고, 검은 고양이, 길고양이가 있다면, 프로그램 내에서 일반적인 고양이를 검은 고양이나 길고양이로 치환해도 전체적인 프로그램이 돌아가야 한다는 뜻이다. 

```python
class Cat:
    def speak(self):
        print('meow')

class BlackCat(Cat):
    def speak(self):
        print("black meow")
    
def speak(cat: Cat):
    cat.speak()

cat = Cat()
speak(cat)
```

여기서 고양이를 검은 고양이라 해도 meow라고 대답할 것이다. 

```python
cat = BlackCat()
speak(cat)
```

그런데 여기서 생선 클래스를 넣으라는 요청이 들어왔다 했을 때, 생선은 말을 할 수 없으므로 오류처리를 할 것이다. 

```python
class Fish(Cat):
    def speak(self):
        raise Exception("Fish cannot speak")

cat = Fish()
speak(cat)
```

따라서 cat을 Fish의 인스턴스로 한다면 말을 하지 못한다. 이 경우, 리스코프 치환 법칙을 위배하게 된다. 

이를 해결하기 위해서는 전체적인 클래스 구조를 잡고 만들어야 한다. 또는 다른 방법을 사용해야 한다. 

