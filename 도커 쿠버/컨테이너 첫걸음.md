# 1. 컨테이너 첫걸음

## 1.1. hello-world 실행

```
docker run hello-world
```

실행시 나오는 메세지를 번역해보면 다음과 같다. 

![picture 9](../images/9a70c12be6f6f2540d183581f5d2b33efe3b22108644d837b70f496c9929a34b.png)  

![picture 10](../images/2e9d58b6b9eaef13aca1393c66cfe0ded025d2da00f3a1f101c5d845509d7f4f.png)  

1~4의 내용을 확인해보자. 

1. 터미널 혹은 커맨드 프롬프트에서 'docker run hello-world'를 실행하면 도커 데몬에 접속. 도커의 공식 문서에는 데몬을 엔진이라 부르기 때문에 엔진이란 표현을 사용. 
2. 커맨드 중 hello-world는 리포지터리의 이름임. 도커 엔진은 도커 허브의 리포지터리로부터 컨테이너를 위한 이미지를 로컬에 다운로드
3. 도커 엔진이 이미지로부터 컨테이너를 생성. 컨테이너상의 프로세스가 메시지를 표준 출력에 쓰기 시작.
4. 도커 엔진은 컨테이너의 표준 출력을 도커 커맨드에 보내고 터미널에 표시

이미지: 운영체제와 소프트웨어를 담는 컨테이너 실행 이전 상태

리포지터리: 이미지의 보관장소

레지스트리: windows의 설정 정보 DB를 말하기도 하지만, 도커에서는 리포지터리의 집합체로서 리포지터리를 제공하는 서버를 말함

## 1.2. 컨테이너의 생명 주기와 도커 커맨드

컨테이너는 세 가지 상태를 가짐. 

컨테이너 상태의 종류
1. 이미지
2. 실행
3. 정지

![picture 11](../images/507f265069187f9ccd487e41383b9461b411f2832037f34a26251d5d1fd4ac8a.png)  

각 상태 전이를 확인해보자. 

**1. 이미지 다운로드**

`docker pull 리포지터리명[:태그]`를 실행하면 원격 리포지터리로부터 로드한다. 

![picture 12](../images/c2d63b08df8e2aaaf45f6a3926a6c94fa8d5f111a19e1218231adb7b8b5cbfb8.png)  

**2. 컨테이너 실행**

명령어에서 `docker run [옵션] 리포지터리명:태그 [커맨드] [인자]`는 지정한 이미지를 모형으로 컨테이너를 가동한다. 로컬에 없으면 원격에서 가져오는데 기본값 원격 리포지터리는 도커 허브이다. 

![picture 13](../images/ad3eb56e6b817b4a5a323e5ed84a4ba4f843ce5679819ea95272f2f558a9459c.png)  

![picture 14](../images/1de9fde9bfa9a9a84ec6ac9008e883cddabe42429240f308bd98409a0ac9d004.png)  

**3. 컨테이너 상태 출력**

커맨드 `docker ps [옵션]`은 실행, 정지상태의 컨테이너 목록 출력. 옵션을 생략하면 실행 중인 컨테이너만 출력. `-a`를 추가하면 정지도 출력

![picture 15](../images/4dbeecfecb31ea36b25dbea4cc2a58bf43491092b68ccf11da69359f52908406.png)  

**4. 로그 출력**

정지 상태인 컨테이너는 삭제까지 남아있으며, 실행 중 발생한 표준 출력과 표준 에러 출력을 간직한다. `docker logs [옵션] 컨테이너ID | 컨테이너명`으로 확인할 수 있다. 

**5. 컨테이너 정지**

실행중인 컨테이너를 다음과 같이 정지할 수 있다.
`컨테이너의 PID=1인 프로세스가 종료한다.`
`docker stop 컨테이너너ID | 컨테이너명`
`docker kill 컨테이너ID | 컨테이너명`

*책 예시가 뭔가 이상하네요. rm 써놓고 kill이라 하네요... p.117*

**6. 컨테이너 재기동**

정지 상태인 컨테이너를 `docker start [옵션] 컨테이너ID | 컨테이너명` 으로 재기동 가능(*그런데 해보니까 attach가 되던데...*)

**7. 컨테이너 변경사항 리포지토리 저장**

기동한 컨테이너의 리눅스에서도 가상 서버처럼 필요한 패키지를 설치하거나 업데이트 할 수 있다. 

`docker commit [옵션] 컨테이너ID | 컨테이너명 리포지터리명[:태그]`

컨테이너의 상태를 이미지로 만들어 리포지터리에 보관 가능

![picture 16](../images/1b7695d8b8f4604345b41ff6f383e6762261a054ffa662a746e766aa8cf2af44.png)  

**8. 이미지를 원격 리포지터리에 보관**

도커 허브를 사용하는 경우
1. 도커 허브에 가입하여 도커 ID를 취득
2. 명령어에 `docker login`으로 ID와 비밀번호 입력하여 로그인
3. 명령어 `docker tag`로 로컬 이미지에 태그 부여
4. 명령어 `docker push`로 이미지를 원격에 업로드
5. 도커 허브에서 확인

![picture 17](../images/31d5ee400e5aae09cd9a1ca88d165079d0a31686af9d0e04f0a25370f84f04cb.png)  

![picture 18](../images/c6e2b88587ec3a4167bafcb1701cf945669ec005afbf106d91d8c9fb1a0d38e2.png)  

![picture 19](../images/53b7704488758dfbea50cdbcf268f4b968fafc40a6f8f913833ed555499e49cc.png)  

**9. 종료 컨테이너 제거**

`docker rm 컨테이너ID | 컨테이너명`

**10. 필요 없어진 이미지를 로컬 리포지토리에서 삭제**

`docker rmi 이미지ID`

## 1.3. 마무리

* 도커 커맨드는 백그라운드에서 돌고 있는 도커 엔진에 명령어를 주어 실행 
* 컨테이너를 실행하기 위해 리눅스 커널이 필요. 맥 윈도우는 가상 머신의 리눅스에서 컨테이너 실행
* 도커 엔진은 docker 커맨드의 요청으로 원격 리포지터리에서 이미지를 다운로드하고 컨테이너를 생성하여 실행하고 애플리케이션의 입출력을 터미널에서 연결하는 역할을 수행

***

# 2. 컨테이너 다루기

## 2.1. 대화형 모드로 컨테이너 기동 정지

### 2.1.1. 대화형 모드로 컨테이너 기동(docker run -it)

대화형 모드로 컨테이너를 기동하기 위해서 다음으로 실행 

`docker run -it 리포지터리명:[태그] 셸`

* -i: 키보드 입력을 표준입력으로 셸에 전달

* -t: 유사 터미널 디바이스(pts)에서 셸을 연결

-it를 이용하면 셸은 터미널과 접속되어있다고 인식하고 셸의 프롬프트를 출력. `root@abcdef...`과 같이 프롬프트가 출력되는데, `abcdef...` 부분이 컨테이너의 호스트이자 ID.

--name 옵션을 이용하면 컨테이너 이름을 지정해서 컨테이너ID 대신 편하게 사용할 수 있다. 

### 2.1.2. 대화형 모드에서 컨테이너 정지

exit를 입력하면 컨테이너를 종료할 수 있다. 


우분투 컨테이너 실행: `docker run -it ubuntu bash`

centos 컨테이너 실행: `docker run --name centos centos:7 bash`

## 2.2. 컨테이너 조작 및 이미지 작성

목표: 레지스트리에 등록된 공식 이미지 우분투와 centos 기동 후 소프트웨어 패키지를 설치한 뒤 이미지 보존하기

실행 중 컨테이너는 IP 주소를 할당받고 이를 바탕으로 컨테이너 간 통신을 수행.

우분투는 apt, centos는 yum사용

컨테이너에 패키지 설치(우분투): `apt-get update && apt-get install -y iputils-ping net-tools iproute2 dnsutils curl`

컨테이너에 패키지 설치(centos): `yum update -y && yum install -y iputils-ping net-tools iproute2 dnsutils curl`

컨테이너를 이미지로 만들어 보관: `docker commit centos my-centos:0.1`

**실행한 컨테이너로 이미지를 많이 만드는 것이 좋을까?**

> 무조건 그렇지는 않다. 왜냐하면 어떤 앱이 설치되었는지 확인하기 어렵기 때문

실행중인 컨테이너의 IP주소는 도커 커맨드로 확인이 가능: `docker inspect [옵션] 컨테이너ID | 컨테이너명`

## 2.3. 여러 터미널에서 조작

2개 이상의 터미널에서 접속하려면? 

`docker exec -it 컨테이너명 bash`

리눅스 서버는 w명령어로 동시에 로그인한 다른 유저 정보를 얻음. 그러나 컨테이너에서는 w커맨드 입력해도 아무것도 나오지 않음. 

이유는 컨테이너에는 로그인을 통한 유저 인증 기능이 없고, 유저 자체를 관리하지 않기 때문. 

tty: 사용중인 터미널 출력

ps ax: 모든 프로세스 목록 출력

## 2.4. 호스트와 컨테이너의 관계

호스트: 컨테이너를 실행하는 리눅스 서버

터미널 1

![picture 20](../images/4ee89c2fd141ce4bc0aa15a10383ea0666b321945a92af8cd4ca7dbf749cd89e.png)  

터미널 2

![picture 21](../images/662528d78ba1f96e9878a0ecfd7a53a8cf8b79e391bfefb5c800a2a6ca792029.png)  

터미널 3

![picture 22](../images/c9cf38fe3663fa26d816ab85d91a61286055ecf632094d342fb4637d9c4de075.png)  

이 사실로 알 수 있는 것은 컨테이너의 실체가 프로세스라는 것이다(*갑자기?*). 

*이부분 이해가 안가네요. 왜 갑자기 컨테이너가 프로세스라는건지...*

*확인. wsl에서 확인해보니까 프로세스로 뜨네요.*

## 2.5. 마무리

* 컨테이너를 사용하면 마치 가상 서버에 로그인한 것처럼 셸을 사용하여 명령어를 내릴 수 있음 
* 컨테이너를 여러 개 기동하면 분리된 가상 서버인 것처럼 독립적으로 사용할 수 있음
* 컨테이너는 IP주소를 가지며 호스트의 다른 컨테이너와 통신할 수 있음
* `docker commit`명령어를 통해 컨테이너를 이미지로 만들어 보관 가능
* 리눅스는 멀티유저용이지만 컨테이너는 단일 유저용
* 의도적으로 포트를 열지 않는 이상 외부에서 컨테이너에 접속할 수 없음
* 컨테이너는 호스트의 커널을 공유하는 리눅스 프로세스(왜?)