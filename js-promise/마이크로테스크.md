# 마이크로테스크

[https://ko.javascript.info/microtask-queue](https://ko.javascript.info/microtask-queue)

프라미스 핸들러 .then, .catch, .finally는 항상 비동기적으로 실행된다. 프라미스가 즉시 이행되더라도 .then, .catch, .finally 아래에 있는 코드는 이 핸들러들이 실행되기 전에 실행된다. 

```js
let promise = Promise.resolve();

promise.then(() => alert("프라미스 성공!"));

alert("코드 종료"); // 얼럿 창이 가장 먼저 뜹니다.
```

왜 위의 코드는 코드 종료가 먼저 나오고 프라미스 성공이 나중에 나올까? 

## 마이크로테스크 큐

비동기 작업을 처리하기 위해 ECMA에선 PromiseJobs이라는 내부 큐를 명시한다. V8엔진에서 이를 마이크로테스크 큐라 부른다. 

* 마이크로테스크 큐는 먼저 들어온 작업을 먼저 실행한다. 
* 실행할 것이 아무것도 없다면 마이크로테스크 큐에 있는 작업이 실행된다. 

요약하면 어떤 프라미스가 준비됐다면 프라미스의 .then/catch/finally 핸들러가 큐에 들어간다고 생각하면 된다. 어때 핸들러는 실행되지 않는다. 현재 코드에서 자유로운 상태가 되었을 때에서야 자바스크립트 엔진은 큐에서 작업을 실행시킨다. 

여러 체인을 만든다면 각 핸들러는 비동기적으로 실행된다. 큐에 들어간 핸들러 각각은 현재 코드가 완료되고 큐에 적체된 이전 핸들러의 실행이 완료되었을 때 실행된다. 

## 처리되지 못한 거부

처리되지 못한 거부를 js는 어떻게 찾을까? **처리되지 못한 거부는 마이크로테스크 큐 끝에서 프라미스 에러가 처리되지 못할 때 발생**한다. .catch로 추가한 것을 잊는다면 엔진은 마이크로테스크 큐가 빈 이후 unhandlerejection 이벤트를 트리거한다. 