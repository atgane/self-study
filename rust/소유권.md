# 소유권 이해

다른 언어는 가비지 콜렉션을 갖거나, 프로그래머가 명시적으로 메모리를 할당하고 해제해야 한다. 그러나 러스트는 소유권 시스템을 통해 메모리를 관리한다. 컴파일 타임에 컴파일러가 체크할 규칙으로 구성된 소유권 시스템을 이용한다. 소유권 기능의 어떤 것도 런타임 비용이 발생하지 않는다. 

스택에 포인터를 푸싱하는 것은 할당에 해당하지 않는다. 한편 힙 안의 어떤 빈 지점을 찾아 사용중이라 표시하고 그 곳의 포인터를 돌려주는 것을 할당이라 한다. 힙에 있는 데이터는 스택에 있는 데이터에 접근하는 것보다 느린데, 포인터가 가리킨 곳을 따라가야 하기 때문이다. 

**소유권 규칙**
1. 러스트의 각각의 값은 해당값의 오너라 불리는 변수를 갖는다. 
2. 한번에 딱 하나의 오너만 존재한다.
3. 오너가 스코프 밖으로 벗어날 때 값은 버려진다.

스트링은 스트링 리터럴과 메모리를 쓰는 방식이 다르다. 스트링 리터럴은 불변이고 내용물을 컴파일 타임에 알 수 있으므로 빠르다. 그러나 변경이 가능한 경우, 스트링 리터럴보다 스트링을 사용해야 한다. 

스트링 타입은 힙에 메모리 공간을 할당받아 저장받는다. 
1. 런타임에 OS로부터 메모리 요청
2. String의 사용이 끝났을 때 OS에 메모리 반납

1은 String::from을 호출할 때 실행한다. 그러나 2는 다른 언어에서 GC를 사용하거나, 명시적으로 반납하는 코드를 호출해야 하는데, 러스트의 경우 스코프를 벗어나는 순간 자동으로 반납한다. 

변수가 스코프를 벗어나면 특별한 함수 drop을 호출하고 String의 개발자가 메모리를 반환하도록 하는 코드를 집어넣을 수 있다. 

러스트는 다음의 코드가 안된다!

```rs
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

위의 코드는 s1과 s2의 포인터가 가르키는 주소가 서로 같음을 암시한다(복사로 일어나는게 아니다). 이 문제는 s1과 s2가 같은 블록을 탈출하면서 두 번 메모리를 해제하려고 하기 때문에 메모리 안전성에서 버그를 일으킬 수 있다. 메모리 안전을 보장하기 위해 복사를 시도하는 대신 s1이 더 이상 유효하지 않다고 간주하면 위의 경우를 해결할 수 있다. 이를 이동이라 한다. 이동이 일어나면 s1이 무효화되고, s2만 유효한 상태에서 스코프를 벗어나면 메모리 할당을 해제한다. 

```rs
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

한편 스택에만 저장되는 타입은 복사본이 빠르게 만들어질 수 있기 때문에 유효함을 따질 필요가 없다. 

한편, 함수의 값을 넘기면 대입과 마찬가지로 복사된다. 따라서 소유권이 이동된다. 힙에 데이터를 갖는 변수가 스코프를 벗어나면 drop으로 제거된다. 함수가 값을 사용하면서 소유권을 갖지 않게 하려면? 튜플을 쓰는 방법도 있지만, 이를 위해 참조자를 쓸 수 있다. 

# 참조자와 빌림 
```rs
let s1 = String::from("hello");

let len = calculate_length(&s1);
```
&s1 문법은 s1값을 참조하지만 소유하지 않는 참조자를 생성하도록 한다. 소유권을 갖고 있지 않기에 이 참조자가 가리키는 것은 스코프 밖에 벗어나도 메모리를 반납하지 않는다. 함수의 파라미터로  참조자를 만드는 것을 빌림이라 한다. 한편 빌린값은 불변이므로 수정할 수 없다. 

```rs
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

참조 상태에서 변경을 하기 위해 가변 참조자를 이용할 수 있다. s를 mut로 바꾸고, &mut로 가변 참조자를 생성하고, 함수에서 &mut로 가변 참조자를 받아야 한다. 가변 참조자의 특징은 특정 스코프에 가변 참조자를 딱 하나만 만들 수 있다는 것이다. 

데이터 레이스를 방지하기 위해 이러한 제한 조건이 존재한다. 

데이터 레이스는 다음과 같은 세 가지 동작이 발생했을 때 나타나는 특정 레이스 조건이다. 
1. 두 개 이상의 포인터가 동시에 같은 값을 접근한다. 
2. 그 중 적어도 하나의 포인터가 데이터를 쓴다. 
3. 데이터에 접근하는데 동기화를 하는 메커니즘이 없다. 

이런 데이터 레이스에 관한 문제를 러스트는 존재 자체를 막는다. 

가변 참조자와 불변 참조자를 혼용한다면 오류가 발생하는데, 불변 참조자의 사용자는 사용중 값이 바뀔것으로 예상하지 못하기 때문이다. 

댕글링 포인터: 어떤 메모리를 가리키는 포인터를 보존하는 동안, 메모리를 해제함으로써 다른 개체에게 사용하도록 줘버렸을지도 모를 메모리를 참조하고 있는 포인터. 러스트는 이를 방지한다.

```rs
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

라이픙타임 오류를 무시하면, 이 함수의 반환 타입은 빌린 값을 포함하는데 빌린 실제 값이 없다고 나온다. s가 dangle안에서 만들어졌으므로, dangle코드가 끝나면 s는 할당 해제된다. 그런데 참조자를 반환하고 있으므로, 무효화될 수 있다. 러스트는 이를 방지한다. 여기서 해법은 s를 직접 반환하는 것이다. 

# 슬라이스
슬라이스는 소유권을 갖지 않는 데이터 타입이다. 콜렉션 전체가 아닌 콜렉션의 연속된 일련의 요소를 참조할 수 있게 한다. 

String의 일부분에 대해 슬라이스를 하는 경우, String의 참조자를 갖는 것과 비슷하지만, 일부분에 대한 참조이다. 
```rs
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // Error!

    println!("the first word is: {}", word);
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

위의 코드는 에러를 발생한다. 빌림 규칙에서 무언가에 대한 불변 참조자를 만들었을 경우, 가변 참조자를 만들 수 없다는 점을 상기하자. 

String을 슬라이스하면 &str을 반환한다. 또한
```rs
let s = "Hello world";  
```
의 s도 &str이다.

한편 러스트의 경험이 많은 사람이라면 아래와 같이 작성하곤 한다. 
```rs
fn first_word(s: &str) -> &str {
```

그리고 main에서 `let word = first_word(&my_string[..]);`로 보내면 된다. 